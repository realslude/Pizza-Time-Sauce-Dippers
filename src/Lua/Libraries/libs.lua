-- split a string
function string:split(delimiter)
  local result = { }
  local from  = 1
  local delim_from, delim_to = string.find( self, delimiter, from  )
  while delim_from do
    table.insert( result, string.sub( self, from , delim_from-1 ) )
    from  = delim_to + 1
    delim_from, delim_to = string.find( self, delimiter, from  )
  end
  table.insert( result, string.sub( self, from  ) )
  return result
end

rawset(_G, "L_ZCollide", function(mo1,mo2)
	if mo1.z > mo2.height+mo2.z then return false end
	if mo2.z > mo1.height+mo1.z then return false end
	return true
end)

rawset(_G, "G_TicsToMTIME", function(tics, hascents)
	if tics == nil then return "??:??" end
	local minutes = tostring(G_TicsToMinutes(tics))
	local seconds = tostring(G_TicsToSeconds(tics))
	local cents = tostring(G_TicsToCentiseconds(tics))		

    if minutes:len() < 2 then
        minutes = $
    end

    if seconds:len() < 2 then
		seconds = "0"..$
    end
	
	if cents:len() < 2 then
        cents = $
    end
	
	if not hascents then
		return minutes..":"..seconds
	else
		return minutes..":"..seconds.."."..cents
	end
end)

-- evil leafy oooooo
-- probably stupid but ehh
local tpchaseList = {
	{-1, 0},
	{1, 0},
	{0, -1},
	{0, 1},
	-- diagonals !!
	{-1, -1},
	{-1, 1},
	{1, -1},
	{1, 1}
}
local tpchaseZThing = {0, 128*FU}

rawset(_G, "P_TPChase", function(mo, tpx, tpy, tpz, speed)
	if not (mo and mo.valid) then return end
	
	/*local posList = {
		{mo.x-speed, mo.y},
		{mo.x+speed, mo.y},
		{mo.x, mo.y-speed},
		{mo.x, mo.y+speed}
	}*/
	
	local closestDist = {x = mo.x, y = mo.y}
	for key, math in ipairs(tpchaseList) do
		local oldpos = {x = mo.x, y = mo.y, z = mo.z}
		local cur = {mo.x+speed*math[1], mo.y+speed*math[2]}
		
		mo.z = min(max($+128*FU*P_MobjFlip(mo), mo.floorz), mo.ceilingz-mo.height)
		if not P_TryMove(mo, cur[1], cur[2], true) then continue end
		P_SetOrigin(mo, oldpos.x, oldpos.y, oldpos.z)
		
		local closeDist = R_PointToDist2(closestDist.x, closestDist.y, tpx, tpy)
		local dist = R_PointToDist2(cur[1], cur[2], tpx, tpy)
		if dist < closeDist then
			closestDist.x = cur[1]
			closestDist.y = cur[2]
		end
	end
	
	if closestDist == {x = mo.x, y = mo.y} then return end
	
	P_MoveOrigin(mo, closestDist.x, closestDist.y, mo.z)
	mo.z = (mo.eflags & MFE_VERTICALFLIP) and mo.ceilingz or mo.floorz
	return true
end)

--this is really simple, no other way to make this
rawset(_G, "P_FlyTo", function(mo, fx, fy, fz, sped, addques)
    if mo.valid
        local flyto = P_AproxDistance(P_AproxDistance(fx - mo.x, fy - mo.y), fz - mo.z)
        if flyto < 1
            flyto = 1
        end
		
        if addques
            mo.momx = $ + FixedMul(FixedDiv(fx - mo.x, flyto), sped)
            mo.momy = $ + FixedMul(FixedDiv(fy - mo.y, flyto), sped)
            mo.momz = $ + FixedMul(FixedDiv(fz - mo.z, flyto), sped)
        else
            mo.momx = FixedMul(FixedDiv(fx - mo.x, flyto), sped)
            mo.momy = FixedMul(FixedDiv(fy - mo.y, flyto), sped)
            mo.momz = FixedMul(FixedDiv(fz - mo.z, flyto), sped)
        end    
    end    
end)

rawset(_G, "L_DoBrakes", function(mo,factor)
	mo.momx = FixedMul($,factor)
	mo.momy = FixedMul($,factor)
	mo.momz = FixedMul($,factor)
end)

rawset(_G, "L_SpeedCap", function(mo,limit,factor)
	local spd_xy = R_PointToDist2(0,0,mo.momx,mo.momy)
	local spd, ang =
		R_PointToDist2(0,0,spd_xy,mo.momz),
		R_PointToAngle2(0,0,mo.momx,mo.momy)
	if spd > limit
		if factor == nil
			factor = FixedDiv(limit,spd)
		end
		L_DoBrakes(mo,factor)
		return factor
	end
end)

rawset(_G, "L_FixedDecimal", function(str,maxdecimal)
	if str == nil or tostring(str) == nil
		return "<invalid FixedDecimal>"
	end
	local number = tonumber(str)
	maxdecimal = ($ != nil) and $ or 3
	if tonumber(str) == 0 return '0' end
	local polarity = abs(number)/number
	local str_polarity = (polarity < 0) and '-' or ''
	local str_whole = tostring(abs(number/FRACUNIT))
	if maxdecimal == 0
		return str_polarity..str_whole
	end
	local decimal = number%FRACUNIT
	decimal = FRACUNIT + $
	decimal = FixedMul($,FRACUNIT*10^maxdecimal)
	decimal = $>>FRACBITS
	local str_decimal = string.sub(decimal,2)
	return str_polarity..str_whole..'.'..str_decimal
end)

-- clamp
rawset(_G, "clamp", function(low, value, high)
	if value < low then
		value = low
	elseif value > high then
		value = high
	end
	
	return value
end)

-- inverse clamp
rawset(_G, "iclamp", function(low, value, high)
	if value < low then
		value = low
	elseif value > high then
		value = high
	end
	
	return high-value
end)

rawset(_G, "prtable", function(text, t, prefix, cycles)
    prefix = $ or ""
    cycles = $ or {}

    print(prefix..text.." = {")

    for k, v in pairs(t)
        if type(v) == "table"
            if cycles[v]
                print(prefix.."    "..tostring(k).." = "..tostring(v))
            else
                cycles[v] = true
                prtable(k, v, prefix.."    ", cycles)
            end
        elseif type(v) == "string"
            print(prefix.."    "..tostring(k)..' = "'..v..'"')
        else
			if type(v) == "userdata" and v.valid and v.name
				v = v.name
			end
            print(prefix.."    "..tostring(k).." = "..tostring(v))
        end
    end

    print(prefix.."}")
end)

rawset(_G, "L_ThrustXYZ", function(mo,xyangle,zangle,speed,relative)
	local xythrust = P_ReturnThrustX(nil,zangle,speed)
	local zthrust = P_ReturnThrustY(nil,zangle,speed)
	if relative then
		P_Thrust(mo,xyangle,xythrust)		
		mo.momz = $+zthrust	
	else
		P_InstaThrust(mo,xyangle,xythrust)		
		mo.momz = zthrust	
	end
	return xythrust/FRACUNIT, zthrust/FRACUNIT
end)